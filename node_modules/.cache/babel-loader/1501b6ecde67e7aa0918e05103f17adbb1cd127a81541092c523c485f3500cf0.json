{"ast":null,"code":"'use strict';\n\nconst fs = require('../fs');\nconst path = require('path');\nconst util = require('util');\nfunction getStats(src, dest, opts) {\n  const statFunc = opts.dereference ? file => fs.stat(file, {\n    bigint: true\n  }) : file => fs.lstat(file, {\n    bigint: true\n  });\n  return Promise.all([statFunc(src), statFunc(dest).catch(err => {\n    if (err.code === 'ENOENT') return null;\n    throw err;\n  })]).then(_ref => {\n    let [srcStat, destStat] = _ref;\n    return {\n      srcStat,\n      destStat\n    };\n  });\n}\nfunction getStatsSync(src, dest, opts) {\n  let destStat;\n  const statFunc = opts.dereference ? file => fs.statSync(file, {\n    bigint: true\n  }) : file => fs.lstatSync(file, {\n    bigint: true\n  });\n  const srcStat = statFunc(src);\n  try {\n    destStat = statFunc(dest);\n  } catch (err) {\n    if (err.code === 'ENOENT') return {\n      srcStat,\n      destStat: null\n    };\n    throw err;\n  }\n  return {\n    srcStat,\n    destStat\n  };\n}\nfunction checkPaths(src, dest, funcName, opts, cb) {\n  util.callbackify(getStats)(src, dest, opts, (err, stats) => {\n    if (err) return cb(err);\n    const {\n      srcStat,\n      destStat\n    } = stats;\n    if (destStat) {\n      if (areIdentical(srcStat, destStat)) {\n        const srcBaseName = path.basename(src);\n        const destBaseName = path.basename(dest);\n        if (funcName === 'move' && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n          return cb(null, {\n            srcStat,\n            destStat,\n            isChangingCase: true\n          });\n        }\n        return cb(new Error('Source and destination must not be the same.'));\n      }\n      if (srcStat.isDirectory() && !destStat.isDirectory()) {\n        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));\n      }\n      if (!srcStat.isDirectory() && destStat.isDirectory()) {\n        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));\n      }\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)));\n    }\n    return cb(null, {\n      srcStat,\n      destStat\n    });\n  });\n}\nfunction checkPathsSync(src, dest, funcName, opts) {\n  const {\n    srcStat,\n    destStat\n  } = getStatsSync(src, dest, opts);\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      const srcBaseName = path.basename(src);\n      const destBaseName = path.basename(dest);\n      if (funcName === 'move' && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n        return {\n          srcStat,\n          destStat,\n          isChangingCase: true\n        };\n      }\n      throw new Error('Source and destination must not be the same.');\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);\n    }\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName));\n  }\n  return {\n    srcStat,\n    destStat\n  };\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths(src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src));\n  const destParent = path.resolve(path.dirname(dest));\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb();\n  fs.stat(destParent, {\n    bigint: true\n  }, (err, destStat) => {\n    if (err) {\n      if (err.code === 'ENOENT') return cb();\n      return cb(err);\n    }\n    if (areIdentical(srcStat, destStat)) {\n      return cb(new Error(errMsg(src, dest, funcName)));\n    }\n    return checkParentPaths(src, srcStat, destParent, funcName, cb);\n  });\n}\nfunction checkParentPathsSync(src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src));\n  const destParent = path.resolve(path.dirname(dest));\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return;\n  let destStat;\n  try {\n    destStat = fs.statSync(destParent, {\n      bigint: true\n    });\n  } catch (err) {\n    if (err.code === 'ENOENT') return;\n    throw err;\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName));\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName);\n}\nfunction areIdentical(srcStat, destStat) {\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir(src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i);\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i);\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);\n}\nfunction errMsg(src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;\n}\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir,\n  areIdentical\n};","map":{"version":3,"names":["fs","require","path","util","getStats","src","dest","opts","statFunc","dereference","file","stat","bigint","lstat","Promise","all","catch","err","code","then","_ref","srcStat","destStat","getStatsSync","statSync","lstatSync","checkPaths","funcName","cb","callbackify","stats","areIdentical","srcBaseName","basename","destBaseName","toLowerCase","isChangingCase","Error","isDirectory","isSrcSubdir","errMsg","checkPathsSync","checkParentPaths","srcParent","resolve","dirname","destParent","parse","root","checkParentPathsSync","ino","dev","srcArr","split","sep","filter","i","destArr","reduce","acc","cur","module","exports"],"sources":["C:/Users/wwwna/Desktop/test/node_modules/fs-extra/lib/util/stat.js"],"sourcesContent":["'use strict'\n\nconst fs = require('../fs')\nconst path = require('path')\nconst util = require('util')\n\nfunction getStats (src, dest, opts) {\n  const statFunc = opts.dereference\n    ? (file) => fs.stat(file, { bigint: true })\n    : (file) => fs.lstat(file, { bigint: true })\n  return Promise.all([\n    statFunc(src),\n    statFunc(dest).catch(err => {\n      if (err.code === 'ENOENT') return null\n      throw err\n    })\n  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))\n}\n\nfunction getStatsSync (src, dest, opts) {\n  let destStat\n  const statFunc = opts.dereference\n    ? (file) => fs.statSync(file, { bigint: true })\n    : (file) => fs.lstatSync(file, { bigint: true })\n  const srcStat = statFunc(src)\n  try {\n    destStat = statFunc(dest)\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nfunction checkPaths (src, dest, funcName, opts, cb) {\n  util.callbackify(getStats)(src, dest, opts, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n\n    if (destStat) {\n      if (areIdentical(srcStat, destStat)) {\n        const srcBaseName = path.basename(src)\n        const destBaseName = path.basename(dest)\n        if (funcName === 'move' &&\n          srcBaseName !== destBaseName &&\n          srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n          return cb(null, { srcStat, destStat, isChangingCase: true })\n        }\n        return cb(new Error('Source and destination must not be the same.'))\n      }\n      if (srcStat.isDirectory() && !destStat.isDirectory()) {\n        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n      }\n      if (!srcStat.isDirectory() && destStat.isDirectory()) {\n        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`))\n      }\n    }\n\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return cb(null, { srcStat, destStat })\n  })\n}\n\nfunction checkPathsSync (src, dest, funcName, opts) {\n  const { srcStat, destStat } = getStatsSync(src, dest, opts)\n\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      const srcBaseName = path.basename(src)\n      const destBaseName = path.basename(dest)\n      if (funcName === 'move' &&\n        srcBaseName !== destBaseName &&\n        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n        return { srcStat, destStat, isChangingCase: true }\n      }\n      throw new Error('Source and destination must not be the same.')\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)\n    }\n  }\n\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\n  fs.stat(destParent, { bigint: true }, (err, destStat) => {\n    if (err) {\n      if (err.code === 'ENOENT') return cb()\n      return cb(err)\n    }\n    if (areIdentical(srcStat, destStat)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return checkParentPaths(src, srcStat, destParent, funcName, cb)\n  })\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    destStat = fs.statSync(destParent, { bigint: true })\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\nfunction areIdentical (srcStat, destStat) {\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir,\n  areIdentical\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}